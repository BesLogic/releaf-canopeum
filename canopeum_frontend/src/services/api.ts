//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class BatchClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl ?? "";
  }

  all(): Promise<BatchAnalytics[]> {
    let url_ = this.baseUrl + "/analytics/batches/";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAll(_response);
    });
  }

  protected processAll(response: Response): Promise<BatchAnalytics[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(BatchAnalytics.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<BatchAnalytics[]>(null as any);
  }

  create(body: Batch | undefined): Promise<Batch> {
    let url_ = this.baseUrl + "/analytics/batches/";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreate(_response);
    });
  }

  protected processCreate(response: Response): Promise<Batch> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Batch.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Batch>(null as any);
  }

  detail(batchId: number, body: Batch | undefined): Promise<Batch> {
    let url_ = this.baseUrl + "/analytics/batches/{batchId}/";
    if (batchId === undefined || batchId === null) throw new Error("The parameter 'batchId' must be defined.");
    url_ = url_.replace("{batchId}", encodeURIComponent("" + batchId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDetail(_response);
    });
  }

  protected processDetail(response: Response): Promise<Batch> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Batch.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Batch>(null as any);
  }

  /**
   * @return No response body
   */
  delete(batchId: number): Promise<void> {
    let url_ = this.baseUrl + "/analytics/batches/{batchId}/";
    if (batchId === undefined || batchId === null) throw new Error("The parameter 'batchId' must be defined.");
    url_ = url_.replace("{batchId}", encodeURIComponent("" + batchId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "DELETE",
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDelete(_response);
    });
  }

  protected processDelete(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }
}

export class SiteClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl ?? "";
  }

  all(): Promise<Site[]> {
    let url_ = this.baseUrl + "/analytics/sites/";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAll(_response);
    });
  }

  protected processAll(response: Response): Promise<Site[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(Site.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Site[]>(null as any);
  }

  create(body: Site): Promise<Site> {
    let url_ = this.baseUrl + "/analytics/sites/";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreate(_response);
    });
  }

  protected processCreate(response: Response): Promise<Site> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Site.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Site>(null as any);
  }

  detail(siteId: number): Promise<Site> {
    let url_ = this.baseUrl + "/analytics/sites/{siteId}/";
    if (siteId === undefined || siteId === null) throw new Error("The parameter 'siteId' must be defined.");
    url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDetail(_response);
    });
  }

  protected processDetail(response: Response): Promise<Site> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Site.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Site>(null as any);
  }

  update(siteId: number, body: Site): Promise<Site> {
    let url_ = this.baseUrl + "/analytics/sites/{siteId}/";
    if (siteId === undefined || siteId === null) throw new Error("The parameter 'siteId' must be defined.");
    url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdate(_response);
    });
  }

  protected processUpdate(response: Response): Promise<Site> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Site.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Site>(null as any);
  }

  delete(siteId: number): Promise<{ [key: string]: any }> {
    let url_ = this.baseUrl + "/analytics/sites/{siteId}/";
    if (siteId === undefined || siteId === null) throw new Error("The parameter 'siteId' must be defined.");
    url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "DELETE",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDelete(_response);
    });
  }

  protected processDelete(response: Response): Promise<{ [key: string]: any }> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200) {
          result200 = {} as any;
          for (let key in resultData200) {
            if (resultData200.hasOwnProperty(key))
              (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
          }
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<{ [key: string]: any }>(null as any);
  }

  summarydetail(siteId: number): Promise<SiteSummary> {
    let url_ = this.baseUrl + "/analytics/sites/{siteId}/summary";
    if (siteId === undefined || siteId === null) throw new Error("The parameter 'siteId' must be defined.");
    url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSummarydetail(_response);
    });
  }

  protected processSummarydetail(response: Response): Promise<SiteSummary> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SiteSummary.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SiteSummary>(null as any);
  }

  summary(): Promise<SiteSummary[]> {
    let url_ = this.baseUrl + "/analytics/sites/summary";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSummary(_response);
    });
  }

  protected processSummary(response: Response): Promise<SiteSummary[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(SiteSummary.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SiteSummary[]>(null as any);
  }

  social(): Promise<SiteSocial> {
    let url_ = this.baseUrl + "/social/sites/";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSocial(_response);
    });
  }

  protected processSocial(response: Response): Promise<SiteSocial> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SiteSocial.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SiteSocial>(null as any);
  }
}

export class SchemaClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl ?? "";
  }

  retrieve(format: Format | undefined, lang: Lang | undefined): Promise<{ [key: string]: any }> {
    let url_ = this.baseUrl + "/api/schema/?";
    if (format === null) throw new Error("The parameter 'format' cannot be null.");
    else if (format !== undefined) url_ += "format=" + encodeURIComponent("" + format) + "&";
    if (lang === null) throw new Error("The parameter 'lang' cannot be null.");
    else if (lang !== undefined) url_ += "lang=" + encodeURIComponent("" + lang) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "application/vnd.oai.openapi",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRetrieve(_response);
    });
  }

  protected processRetrieve(response: Response): Promise<{ [key: string]: any }> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200) {
          result200 = {} as any;
          for (let key in resultData200) {
            if (resultData200.hasOwnProperty(key))
              (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
          }
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<{ [key: string]: any }>(null as any);
  }
}

export class AuthenticationClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl ?? "";
  }

  login(body: AuthUser): Promise<User> {
    let url_ = this.baseUrl + "/auth/login/";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLogin(_response);
    });
  }

  protected processLogin(response: Response): Promise<User> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = User.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<User>(null as any);
  }

  logout(): Promise<{ [key: string]: any }> {
    let url_ = this.baseUrl + "/auth/logout/";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLogout(_response);
    });
  }

  protected processLogout(response: Response): Promise<{ [key: string]: any }> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200) {
          result200 = {} as any;
          for (let key in resultData200) {
            if (resultData200.hasOwnProperty(key))
              (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
          }
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<{ [key: string]: any }>(null as any);
  }

  register(body: User): Promise<AuthUser> {
    let url_ = this.baseUrl + "/auth/register/";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRegister(_response);
    });
  }

  protected processRegister(response: Response): Promise<AuthUser> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = AuthUser.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<AuthUser>(null as any);
  }
}

export class PostClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl ?? "";
  }

  all(): Promise<Post[]> {
    let url_ = this.baseUrl + "/social/posts/";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAll(_response);
    });
  }

  protected processAll(response: Response): Promise<Post[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(Post.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Post[]>(null as any);
  }

  create(body: Post): Promise<Post> {
    let url_ = this.baseUrl + "/social/posts/";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreate(_response);
    });
  }

  protected processCreate(response: Response): Promise<Post> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Post.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Post>(null as any);
  }
}

export class CommentClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl ?? "";
  }

  all(postId: number): Promise<Comment[]> {
    let url_ = this.baseUrl + "/social/posts/{postId}/comments/";
    if (postId === undefined || postId === null) throw new Error("The parameter 'postId' must be defined.");
    url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAll(_response);
    });
  }

  protected processAll(response: Response): Promise<Comment[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(Comment.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Comment[]>(null as any);
  }

  create(postId: number, body: Comment | undefined): Promise<Comment> {
    let url_ = this.baseUrl + "/social/posts/{postId}/comments/";
    if (postId === undefined || postId === null) throw new Error("The parameter 'postId' must be defined.");
    url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreate(_response);
    });
  }

  protected processCreate(response: Response): Promise<Comment> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Comment.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Comment>(null as any);
  }

  /**
   * @return No response body
   */
  delete(commentId: number, postId: number): Promise<void> {
    let url_ = this.baseUrl + "/social/posts/{postId}/comments/{commentId}/";
    if (commentId === undefined || commentId === null) throw new Error("The parameter 'commentId' must be defined.");
    url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
    if (postId === undefined || postId === null) throw new Error("The parameter 'postId' must be defined.");
    url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "DELETE",
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDelete(_response);
    });
  }

  protected processDelete(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }
}

export class LikeClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl ?? "";
  }

  all(postId: number, body: Like | undefined): Promise<Like> {
    let url_ = this.baseUrl + "/social/posts/{postId}/likes/";
    if (postId === undefined || postId === null) throw new Error("The parameter 'postId' must be defined.");
    url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAll(_response);
    });
  }

  protected processAll(response: Response): Promise<Like> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Like.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Like>(null as any);
  }
}

export class SocialClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl ?? "";
  }

  2(siteId: number): Promise<SiteSocial> {
    let url_ = this.baseUrl + "/social/sites/{siteId}/";
    if (siteId === undefined || siteId === null) throw new Error("The parameter 'siteId' must be defined.");
    url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.process2(_response);
    });
  }

  protected process2(response: Response): Promise<SiteSocial> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SiteSocial.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SiteSocial>(null as any);
  }
}

export class AnnouncementClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl ?? "";
  }

  update(siteId: number, body: Announcement | undefined): Promise<Announcement> {
    let url_ = this.baseUrl + "/social/sites/{siteId}/announcements/";
    if (siteId === undefined || siteId === null) throw new Error("The parameter 'siteId' must be defined.");
    url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdate(_response);
    });
  }

  protected processUpdate(response: Response): Promise<Announcement> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Announcement.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Announcement>(null as any);
  }
}

export class ContactClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl ?? "";
  }

  update(contactId: number, siteId: number, body: Contact | undefined): Promise<Contact> {
    let url_ = this.baseUrl + "/social/sites/{siteId}/contacts/{contactId}/";
    if (contactId === undefined || contactId === null) throw new Error("The parameter 'contactId' must be defined.");
    url_ = url_.replace("{contactId}", encodeURIComponent("" + contactId));
    if (siteId === undefined || siteId === null) throw new Error("The parameter 'siteId' must be defined.");
    url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdate(_response);
    });
  }

  protected processUpdate(response: Response): Promise<Contact> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Contact.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Contact>(null as any);
  }
}

export class WidgetClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl ?? "";
  }

  all(siteId: number, body: Widget | undefined): Promise<Widget> {
    let url_ = this.baseUrl + "/social/sites/{siteId}/widgets/";
    if (siteId === undefined || siteId === null) throw new Error("The parameter 'siteId' must be defined.");
    url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAll(_response);
    });
  }

  protected processAll(response: Response): Promise<Widget> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Widget.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Widget>(null as any);
  }

  detail(siteId: number, widgetId: number, body: Widget | undefined): Promise<Widget> {
    let url_ = this.baseUrl + "/social/sites/{siteId}/widgets/{widgetId}/";
    if (siteId === undefined || siteId === null) throw new Error("The parameter 'siteId' must be defined.");
    url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
    if (widgetId === undefined || widgetId === null) throw new Error("The parameter 'widgetId' must be defined.");
    url_ = url_.replace("{widgetId}", encodeURIComponent("" + widgetId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDetail(_response);
    });
  }

  protected processDetail(response: Response): Promise<Widget> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Widget.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Widget>(null as any);
  }

  /**
   * @return No response body
   */
  delete(siteId: number, widgetId: number): Promise<void> {
    let url_ = this.baseUrl + "/social/sites/{siteId}/widgets/{widgetId}/";
    if (siteId === undefined || siteId === null) throw new Error("The parameter 'siteId' must be defined.");
    url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
    if (widgetId === undefined || widgetId === null) throw new Error("The parameter 'widgetId' must be defined.");
    url_ = url_.replace("{widgetId}", encodeURIComponent("" + widgetId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "DELETE",
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDelete(_response);
    });
  }

  protected processDelete(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }
}

export class UserClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl ?? "";
  }

  all(body: User): Promise<User> {
    let url_ = this.baseUrl + "/users/";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAll(_response);
    });
  }

  protected processAll(response: Response): Promise<User> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = User.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<User>(null as any);
  }

  detail(userId: number): Promise<User> {
    let url_ = this.baseUrl + "/users/{userId}/";
    if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDetail(_response);
    });
  }

  protected processDetail(response: Response): Promise<User> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = User.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<User>(null as any);
  }

  update(userId: number, body: User): Promise<User> {
    let url_ = this.baseUrl + "/users/{userId}/";
    if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdate(_response);
    });
  }

  protected processUpdate(response: Response): Promise<User> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = User.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<User>(null as any);
  }

  /**
   * @return No response body
   */
  delete(userId: number): Promise<void> {
    let url_ = this.baseUrl + "/users/{userId}/";
    if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "DELETE",
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDelete(_response);
    });
  }

  protected processDelete(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }
}

export class CurrentClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl ?? "";
  }

  user(): Promise<User> {
    let url_ = this.baseUrl + "/users/current_user/";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUser(_response);
    });
  }

  protected processUser(response: Response): Promise<User> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = User.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<User>(null as any);
  }
}

export class Announcement implements IAnnouncement {
  readonly id!: number;
  body?: string | undefined;
  link?: string | undefined;

  [key: string]: any;

  constructor(data?: IAnnouncement) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      (<any>this).id = _data["id"];
      this.body = _data["body"];
      this.link = _data["link"];
    }
  }

  static fromJS(data: any): Announcement {
    data = typeof data === "object" ? data : {};
    let result = new Announcement();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["id"] = this.id;
    data["body"] = this.body;
    data["link"] = this.link;
    return data;
  }
}

export interface IAnnouncement {
  id: number;
  body?: string | undefined;
  link?: string | undefined;

  [key: string]: any;
}

export class AuthUser implements IAuthUser {
  readonly id!: number;
  /** Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. */
  username!: string;
  email?: string;
  password!: string;

  [key: string]: any;

  constructor(data?: IAuthUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      (<any>this).id = _data["id"];
      this.username = _data["username"];
      this.email = _data["email"];
      this.password = _data["password"];
    }
  }

  static fromJS(data: any): AuthUser {
    data = typeof data === "object" ? data : {};
    let result = new AuthUser();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["id"] = this.id;
    data["username"] = this.username;
    data["email"] = this.email;
    data["password"] = this.password;
    return data;
  }
}

export interface IAuthUser {
  id: number;
  /** Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. */
  username: string;
  email?: string;
  password: string;

  [key: string]: any;
}

export class Batch implements IBatch {
  readonly id!: number;
  created_at?: Date | undefined;
  name?: string | undefined;
  sponsor?: string | undefined;
  size?: string | undefined;
  soil_condition?: string | undefined;
  total_number_seed?: number | undefined;
  total_propagation?: number | undefined;
  site?: number | undefined;

  [key: string]: any;

  constructor(data?: IBatch) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      (<any>this).id = _data["id"];
      this.created_at = _data["created_at"] ? new Date(_data["created_at"].toString()) : <any>undefined;
      this.name = _data["name"];
      this.sponsor = _data["sponsor"];
      this.size = _data["size"];
      this.soil_condition = _data["soil_condition"];
      this.total_number_seed = _data["total_number_seed"];
      this.total_propagation = _data["total_propagation"];
      this.site = _data["site"];
    }
  }

  static fromJS(data: any): Batch {
    data = typeof data === "object" ? data : {};
    let result = new Batch();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["id"] = this.id;
    data["created_at"] = this.created_at ? this.created_at.toISOString() : <any>undefined;
    data["name"] = this.name;
    data["sponsor"] = this.sponsor;
    data["size"] = this.size;
    data["soil_condition"] = this.soil_condition;
    data["total_number_seed"] = this.total_number_seed;
    data["total_propagation"] = this.total_propagation;
    data["site"] = this.site;
    return data;
  }
}

export interface IBatch {
  id: number;
  created_at?: Date | undefined;
  name?: string | undefined;
  sponsor?: string | undefined;
  size?: string | undefined;
  soil_condition?: string | undefined;
  total_number_seed?: number | undefined;
  total_propagation?: number | undefined;
  site?: number | undefined;

  [key: string]: any;
}

export class BatchAnalytics implements IBatchAnalytics {
  readonly id!: number;
  name?: string | undefined;
  size?: string | undefined;
  soil_condition?: string | undefined;
  readonly fertilizers!: string;
  readonly mulch_layers!: string;
  readonly supported_species!: string;
  readonly plant_count!: string;
  readonly survived_count!: string;
  readonly replace_count!: string;
  readonly seed_collected_count!: string;
  readonly seeds!: string;
  readonly species!: string;

  [key: string]: any;

  constructor(data?: IBatchAnalytics) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      (<any>this).id = _data["id"];
      this.name = _data["name"];
      this.size = _data["size"];
      this.soil_condition = _data["soil_condition"];
      (<any>this).fertilizers = _data["fertilizers"];
      (<any>this).mulch_layers = _data["mulch_layers"];
      (<any>this).supported_species = _data["supported_species"];
      (<any>this).plant_count = _data["plant_count"];
      (<any>this).survived_count = _data["survived_count"];
      (<any>this).replace_count = _data["replace_count"];
      (<any>this).seed_collected_count = _data["seed_collected_count"];
      (<any>this).seeds = _data["seeds"];
      (<any>this).species = _data["species"];
    }
  }

  static fromJS(data: any): BatchAnalytics {
    data = typeof data === "object" ? data : {};
    let result = new BatchAnalytics();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["id"] = this.id;
    data["name"] = this.name;
    data["size"] = this.size;
    data["soil_condition"] = this.soil_condition;
    data["fertilizers"] = this.fertilizers;
    data["mulch_layers"] = this.mulch_layers;
    data["supported_species"] = this.supported_species;
    data["plant_count"] = this.plant_count;
    data["survived_count"] = this.survived_count;
    data["replace_count"] = this.replace_count;
    data["seed_collected_count"] = this.seed_collected_count;
    data["seeds"] = this.seeds;
    data["species"] = this.species;
    return data;
  }
}

export interface IBatchAnalytics {
  id: number;
  name?: string | undefined;
  size?: string | undefined;
  soil_condition?: string | undefined;
  fertilizers: string;
  mulch_layers: string;
  supported_species: string;
  plant_count: string;
  survived_count: string;
  replace_count: string;
  seed_collected_count: string;
  seeds: string;
  species: string;

  [key: string]: any;
}

export class Comment implements IComment {
  readonly id!: number;
  body?: string | undefined;
  auth_user?: number | undefined;
  created_at?: Date | undefined;

  [key: string]: any;

  constructor(data?: IComment) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      (<any>this).id = _data["id"];
      this.body = _data["body"];
      this.auth_user = _data["auth_user"];
      this.created_at = _data["created_at"] ? new Date(_data["created_at"].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): Comment {
    data = typeof data === "object" ? data : {};
    let result = new Comment();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["id"] = this.id;
    data["body"] = this.body;
    data["auth_user"] = this.auth_user;
    data["created_at"] = this.created_at ? this.created_at.toISOString() : <any>undefined;
    return data;
  }
}

export interface IComment {
  id: number;
  body?: string | undefined;
  auth_user?: number | undefined;
  created_at?: Date | undefined;

  [key: string]: any;
}

export class Contact implements IContact {
  readonly id!: number;
  address?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  facebook_link?: string | undefined;
  x_link?: string | undefined;
  instagram_link?: string | undefined;
  linkedin_link?: string | undefined;

  [key: string]: any;

  constructor(data?: IContact) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      (<any>this).id = _data["id"];
      this.address = _data["address"];
      this.email = _data["email"];
      this.phone = _data["phone"];
      this.facebook_link = _data["facebook_link"];
      this.x_link = _data["x_link"];
      this.instagram_link = _data["instagram_link"];
      this.linkedin_link = _data["linkedin_link"];
    }
  }

  static fromJS(data: any): Contact {
    data = typeof data === "object" ? data : {};
    let result = new Contact();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["id"] = this.id;
    data["address"] = this.address;
    data["email"] = this.email;
    data["phone"] = this.phone;
    data["facebook_link"] = this.facebook_link;
    data["x_link"] = this.x_link;
    data["instagram_link"] = this.instagram_link;
    data["linkedin_link"] = this.linkedin_link;
    return data;
  }
}

export interface IContact {
  id: number;
  address?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  facebook_link?: string | undefined;
  x_link?: string | undefined;
  instagram_link?: string | undefined;
  linkedin_link?: string | undefined;

  [key: string]: any;
}

export class Coordinates implements ICoordinates {
  readonly id!: number;
  dms_latitude?: string | undefined;
  dms_longitude?: string | undefined;
  dd_latitude?: string | undefined;
  dd_longitude?: string | undefined;
  address?: string | undefined;

  [key: string]: any;

  constructor(data?: ICoordinates) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      (<any>this).id = _data["id"];
      this.dms_latitude = _data["dms_latitude"];
      this.dms_longitude = _data["dms_longitude"];
      this.dd_latitude = _data["dd_latitude"];
      this.dd_longitude = _data["dd_longitude"];
      this.address = _data["address"];
    }
  }

  static fromJS(data: any): Coordinates {
    data = typeof data === "object" ? data : {};
    let result = new Coordinates();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["id"] = this.id;
    data["dms_latitude"] = this.dms_latitude;
    data["dms_longitude"] = this.dms_longitude;
    data["dd_latitude"] = this.dd_latitude;
    data["dd_longitude"] = this.dd_longitude;
    data["address"] = this.address;
    return data;
  }
}

export interface ICoordinates {
  id: number;
  dms_latitude?: string | undefined;
  dms_longitude?: string | undefined;
  dd_latitude?: string | undefined;
  dd_longitude?: string | undefined;
  address?: string | undefined;

  [key: string]: any;
}

export class Like implements ILike {
  readonly id!: number;
  auth_user?: number | undefined;
  post?: number | undefined;

  [key: string]: any;

  constructor(data?: ILike) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      (<any>this).id = _data["id"];
      this.auth_user = _data["auth_user"];
      this.post = _data["post"];
    }
  }

  static fromJS(data: any): Like {
    data = typeof data === "object" ? data : {};
    let result = new Like();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["id"] = this.id;
    data["auth_user"] = this.auth_user;
    data["post"] = this.post;
    return data;
  }
}

export interface ILike {
  id: number;
  auth_user?: number | undefined;
  post?: number | undefined;

  [key: string]: any;
}

export class Post implements IPost {
  readonly id!: number;
  site!: SiteOverview;
  created_at?: Date | undefined;
  body?: string | undefined;
  like_count?: number | undefined;
  share_count?: number | undefined;
  readonly comment_count!: string;
  readonly has_liked!: string;

  [key: string]: any;

  constructor(data?: IPost) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.site = new SiteOverview();
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      (<any>this).id = _data["id"];
      this.site = _data["site"] ? SiteOverview.fromJS(_data["site"]) : new SiteOverview();
      this.created_at = _data["created_at"] ? new Date(_data["created_at"].toString()) : <any>undefined;
      this.body = _data["body"];
      this.like_count = _data["like_count"];
      this.share_count = _data["share_count"];
      (<any>this).comment_count = _data["comment_count"];
      (<any>this).has_liked = _data["has_liked"];
    }
  }

  static fromJS(data: any): Post {
    data = typeof data === "object" ? data : {};
    let result = new Post();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["id"] = this.id;
    data["site"] = this.site ? this.site.toJSON() : <any>undefined;
    data["created_at"] = this.created_at ? this.created_at.toISOString() : <any>undefined;
    data["body"] = this.body;
    data["like_count"] = this.like_count;
    data["share_count"] = this.share_count;
    data["comment_count"] = this.comment_count;
    data["has_liked"] = this.has_liked;
    return data;
  }
}

export interface IPost {
  id: number;
  site: SiteOverview;
  created_at?: Date | undefined;
  body?: string | undefined;
  like_count?: number | undefined;
  share_count?: number | undefined;
  comment_count: string;
  has_liked: string;

  [key: string]: any;
}

export class Site implements ISite {
  readonly id!: number;
  site_type!: SiteType;
  coordinate!: Coordinates;
  readonly site_tree_species!: string;
  contact!: Contact;
  announcement!: Announcement;
  name?: string | undefined;
  description?: string | undefined;
  size?: string | undefined;
  research_partnership?: boolean | undefined;
  visible_map?: boolean | undefined;
  visitor_count?: number | undefined;
  image?: number | undefined;

  [key: string]: any;

  constructor(data?: ISite) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.site_type = new SiteType();
      this.coordinate = new Coordinates();
      this.contact = new Contact();
      this.announcement = new Announcement();
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      (<any>this).id = _data["id"];
      this.site_type = _data["site_type"] ? SiteType.fromJS(_data["site_type"]) : new SiteType();
      this.coordinate = _data["coordinate"] ? Coordinates.fromJS(_data["coordinate"]) : new Coordinates();
      (<any>this).site_tree_species = _data["site_tree_species"];
      this.contact = _data["contact"] ? Contact.fromJS(_data["contact"]) : new Contact();
      this.announcement = _data["announcement"] ? Announcement.fromJS(_data["announcement"]) : new Announcement();
      this.name = _data["name"];
      this.description = _data["description"];
      this.size = _data["size"];
      this.research_partnership = _data["research_partnership"];
      this.visible_map = _data["visible_map"];
      this.visitor_count = _data["visitor_count"];
      this.image = _data["image"];
    }
  }

  static fromJS(data: any): Site {
    data = typeof data === "object" ? data : {};
    let result = new Site();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["id"] = this.id;
    data["site_type"] = this.site_type ? this.site_type.toJSON() : <any>undefined;
    data["coordinate"] = this.coordinate ? this.coordinate.toJSON() : <any>undefined;
    data["site_tree_species"] = this.site_tree_species;
    data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
    data["announcement"] = this.announcement ? this.announcement.toJSON() : <any>undefined;
    data["name"] = this.name;
    data["description"] = this.description;
    data["size"] = this.size;
    data["research_partnership"] = this.research_partnership;
    data["visible_map"] = this.visible_map;
    data["visitor_count"] = this.visitor_count;
    data["image"] = this.image;
    return data;
  }
}

export interface ISite {
  id: number;
  site_type: SiteType;
  coordinate: Coordinates;
  site_tree_species: string;
  contact: Contact;
  announcement: Announcement;
  name?: string | undefined;
  description?: string | undefined;
  size?: string | undefined;
  research_partnership?: boolean | undefined;
  visible_map?: boolean | undefined;
  visitor_count?: number | undefined;
  image?: number | undefined;

  [key: string]: any;
}

export class SiteOverview implements ISiteOverview {
  readonly id!: number;
  name?: string | undefined;

  [key: string]: any;

  constructor(data?: ISiteOverview) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      (<any>this).id = _data["id"];
      this.name = _data["name"];
    }
  }

  static fromJS(data: any): SiteOverview {
    data = typeof data === "object" ? data : {};
    let result = new SiteOverview();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["id"] = this.id;
    data["name"] = this.name;
    return data;
  }
}

export interface ISiteOverview {
  id: number;
  name?: string | undefined;

  [key: string]: any;
}

export class SiteSocial implements ISiteSocial {
  name?: string | undefined;
  site_type!: SiteType;
  image?: number | undefined;
  description?: string | undefined;
  contact!: Contact;
  announcement!: Announcement;
  readonly sponsors!: string;
  readonly widget!: string;

  [key: string]: any;

  constructor(data?: ISiteSocial) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.site_type = new SiteType();
      this.contact = new Contact();
      this.announcement = new Announcement();
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.name = _data["name"];
      this.site_type = _data["site_type"] ? SiteType.fromJS(_data["site_type"]) : new SiteType();
      this.image = _data["image"];
      this.description = _data["description"];
      this.contact = _data["contact"] ? Contact.fromJS(_data["contact"]) : new Contact();
      this.announcement = _data["announcement"] ? Announcement.fromJS(_data["announcement"]) : new Announcement();
      (<any>this).sponsors = _data["sponsors"];
      (<any>this).widget = _data["widget"];
    }
  }

  static fromJS(data: any): SiteSocial {
    data = typeof data === "object" ? data : {};
    let result = new SiteSocial();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["name"] = this.name;
    data["site_type"] = this.site_type ? this.site_type.toJSON() : <any>undefined;
    data["image"] = this.image;
    data["description"] = this.description;
    data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
    data["announcement"] = this.announcement ? this.announcement.toJSON() : <any>undefined;
    data["sponsors"] = this.sponsors;
    data["widget"] = this.widget;
    return data;
  }
}

export interface ISiteSocial {
  name?: string | undefined;
  site_type: SiteType;
  image?: number | undefined;
  description?: string | undefined;
  contact: Contact;
  announcement: Announcement;
  sponsors: string;
  widget: string;

  [key: string]: any;
}

export class SiteSummary implements ISiteSummary {
  name?: string | undefined;
  site_type!: SiteType;
  readonly plant_count!: string;
  readonly survived_count!: string;
  readonly propagation_count!: string;
  visitor_count?: number | undefined;
  readonly sponsor!: string;
  readonly progress!: string;

  [key: string]: any;

  constructor(data?: ISiteSummary) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.site_type = new SiteType();
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.name = _data["name"];
      this.site_type = _data["site_type"] ? SiteType.fromJS(_data["site_type"]) : new SiteType();
      (<any>this).plant_count = _data["plant_count"];
      (<any>this).survived_count = _data["survived_count"];
      (<any>this).propagation_count = _data["propagation_count"];
      this.visitor_count = _data["visitor_count"];
      (<any>this).sponsor = _data["sponsor"];
      (<any>this).progress = _data["progress"];
    }
  }

  static fromJS(data: any): SiteSummary {
    data = typeof data === "object" ? data : {};
    let result = new SiteSummary();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["name"] = this.name;
    data["site_type"] = this.site_type ? this.site_type.toJSON() : <any>undefined;
    data["plant_count"] = this.plant_count;
    data["survived_count"] = this.survived_count;
    data["propagation_count"] = this.propagation_count;
    data["visitor_count"] = this.visitor_count;
    data["sponsor"] = this.sponsor;
    data["progress"] = this.progress;
    return data;
  }
}

export interface ISiteSummary {
  name?: string | undefined;
  site_type: SiteType;
  plant_count: string;
  survived_count: string;
  propagation_count: string;
  visitor_count?: number | undefined;
  sponsor: string;
  progress: string;

  [key: string]: any;
}

export class SiteType implements ISiteType {
  readonly id!: number;
  readonly en!: string;
  readonly fr!: string;

  [key: string]: any;

  constructor(data?: ISiteType) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      (<any>this).id = _data["id"];
      (<any>this).en = _data["en"];
      (<any>this).fr = _data["fr"];
    }
  }

  static fromJS(data: any): SiteType {
    data = typeof data === "object" ? data : {};
    let result = new SiteType();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["id"] = this.id;
    data["en"] = this.en;
    data["fr"] = this.fr;
    return data;
  }
}

export interface ISiteType {
  id: number;
  en: string;
  fr: string;

  [key: string]: any;
}

export class User implements IUser {
  readonly id!: number;
  password!: string;
  last_login?: Date | undefined;
  /** Designates that this user has all permissions without explicitly assigning them. */
  is_superuser?: boolean;
  /** Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. */
  username!: string;
  first_name?: string;
  last_name?: string;
  email?: string;
  /** Designates whether the user can log into this admin site. */
  is_staff?: boolean;
  /** Designates whether this user should be treated as active. Unselect this instead of deleting accounts. */
  is_active?: boolean;
  date_joined?: Date;
  /** The groups this user belongs to. A user will get all permissions granted to each of their groups. */
  groups?: number[];
  /** Specific permissions for this user. */
  user_permissions?: number[];

  [key: string]: any;

  constructor(data?: IUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      (<any>this).id = _data["id"];
      this.password = _data["password"];
      this.last_login = _data["last_login"] ? new Date(_data["last_login"].toString()) : <any>undefined;
      this.is_superuser = _data["is_superuser"];
      this.username = _data["username"];
      this.first_name = _data["first_name"];
      this.last_name = _data["last_name"];
      this.email = _data["email"];
      this.is_staff = _data["is_staff"];
      this.is_active = _data["is_active"];
      this.date_joined = _data["date_joined"] ? new Date(_data["date_joined"].toString()) : <any>undefined;
      if (Array.isArray(_data["groups"])) {
        this.groups = [] as any;
        for (let item of _data["groups"]) this.groups!.push(item);
      }
      if (Array.isArray(_data["user_permissions"])) {
        this.user_permissions = [] as any;
        for (let item of _data["user_permissions"]) this.user_permissions!.push(item);
      }
    }
  }

  static fromJS(data: any): User {
    data = typeof data === "object" ? data : {};
    let result = new User();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["id"] = this.id;
    data["password"] = this.password;
    data["last_login"] = this.last_login ? this.last_login.toISOString() : <any>undefined;
    data["is_superuser"] = this.is_superuser;
    data["username"] = this.username;
    data["first_name"] = this.first_name;
    data["last_name"] = this.last_name;
    data["email"] = this.email;
    data["is_staff"] = this.is_staff;
    data["is_active"] = this.is_active;
    data["date_joined"] = this.date_joined ? this.date_joined.toISOString() : <any>undefined;
    if (Array.isArray(this.groups)) {
      data["groups"] = [];
      for (let item of this.groups) data["groups"].push(item);
    }
    if (Array.isArray(this.user_permissions)) {
      data["user_permissions"] = [];
      for (let item of this.user_permissions) data["user_permissions"].push(item);
    }
    return data;
  }
}

export interface IUser {
  id: number;
  password: string;
  last_login?: Date | undefined;
  /** Designates that this user has all permissions without explicitly assigning them. */
  is_superuser?: boolean;
  /** Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. */
  username: string;
  first_name?: string;
  last_name?: string;
  email?: string;
  /** Designates whether the user can log into this admin site. */
  is_staff?: boolean;
  /** Designates whether this user should be treated as active. Unselect this instead of deleting accounts. */
  is_active?: boolean;
  date_joined?: Date;
  /** The groups this user belongs to. A user will get all permissions granted to each of their groups. */
  groups?: number[];
  /** Specific permissions for this user. */
  user_permissions?: number[];

  [key: string]: any;
}

export class Widget implements IWidget {
  readonly id!: number;
  title?: string | undefined;
  body?: string | undefined;
  site?: number | undefined;

  [key: string]: any;

  constructor(data?: IWidget) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      (<any>this).id = _data["id"];
      this.title = _data["title"];
      this.body = _data["body"];
      this.site = _data["site"];
    }
  }

  static fromJS(data: any): Widget {
    data = typeof data === "object" ? data : {};
    let result = new Widget();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["id"] = this.id;
    data["title"] = this.title;
    data["body"] = this.body;
    data["site"] = this.site;
    return data;
  }
}

export interface IWidget {
  id: number;
  title?: string | undefined;
  body?: string | undefined;
  site?: number | undefined;

  [key: string]: any;
}

export enum Format {
  Json = "json",
  Yaml = "yaml",
}

export enum Lang {
  Af = "af",
  Ar = "ar",
  ArDz = "ar-dz",
  Ast = "ast",
  Az = "az",
  Be = "be",
  Bg = "bg",
  Bn = "bn",
  Br = "br",
  Bs = "bs",
  Ca = "ca",
  Ckb = "ckb",
  Cs = "cs",
  Cy = "cy",
  Da = "da",
  De = "de",
  Dsb = "dsb",
  El = "el",
  En = "en",
  EnAu = "en-au",
  EnGb = "en-gb",
  Eo = "eo",
  Es = "es",
  EsAr = "es-ar",
  EsCo = "es-co",
  EsMx = "es-mx",
  EsNi = "es-ni",
  EsVe = "es-ve",
  Et = "et",
  Eu = "eu",
  Fa = "fa",
  Fi = "fi",
  Fr = "fr",
  Fy = "fy",
  Ga = "ga",
  Gd = "gd",
  Gl = "gl",
  He = "he",
  Hi = "hi",
  Hr = "hr",
  Hsb = "hsb",
  Hu = "hu",
  Hy = "hy",
  Ia = "ia",
  Id = "id",
  Ig = "ig",
  Io = "io",
  Is = "is",
  It = "it",
  Ja = "ja",
  Ka = "ka",
  Kab = "kab",
  Kk = "kk",
  Km = "km",
  Kn = "kn",
  Ko = "ko",
  Ky = "ky",
  Lb = "lb",
  Lt = "lt",
  Lv = "lv",
  Mk = "mk",
  Ml = "ml",
  Mn = "mn",
  Mr = "mr",
  Ms = "ms",
  My = "my",
  Nb = "nb",
  Ne = "ne",
  Nl = "nl",
  Nn = "nn",
  Os = "os",
  Pa = "pa",
  Pl = "pl",
  Pt = "pt",
  PtBr = "pt-br",
  Ro = "ro",
  Ru = "ru",
  Sk = "sk",
  Sl = "sl",
  Sq = "sq",
  Sr = "sr",
  SrLatn = "sr-latn",
  Sv = "sv",
  Sw = "sw",
  Ta = "ta",
  Te = "te",
  Tg = "tg",
  Th = "th",
  Tk = "tk",
  Tr = "tr",
  Tt = "tt",
  Udm = "udm",
  Ug = "ug",
  Uk = "uk",
  Ur = "ur",
  Uz = "uz",
  Vi = "vi",
  ZhHans = "zh-hans",
  ZhHant = "zh-hant",
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}
