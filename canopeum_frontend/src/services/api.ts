// ----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
// ----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : window as any
    this.baseUrl = baseUrl ?? ''
  }

  batchAll(): Promise<BatchAnalytics[]> {
    let url_ = this.baseUrl + '/analytics/batches/'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processBatchAll(_response)
    })
  }

  protected processBatchAll(response: Response): Promise<BatchAnalytics[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        if (Array.isArray(resultData200)) {
          result200 = [] as any
          for (let item of resultData200) {
            result200!.push(BatchAnalytics.fromJS(item))
          }
        } else {
          result200 = <any> null
        }
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<BatchAnalytics[]>(null as any)
  }

  batchCreate(body: Batch | undefined): Promise<Batch> {
    let url_ = this.baseUrl + '/analytics/batches/'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processBatchCreate(_response)
    })
  }

  protected processBatchCreate(response: Response): Promise<Batch> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = Batch.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<Batch>(null as any)
  }

  batchUpdate(batchId: number, body: PatchedBatch | undefined): Promise<Batch> {
    let url_ = this.baseUrl + '/analytics/batches/{batchId}/'
    if (batchId === undefined || batchId === null) {
      throw new Error("The parameter 'batchId' must be defined.")
    }
    url_ = url_.replace('{batchId}', encodeURIComponent('' + batchId))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processBatchUpdate(_response)
    })
  }

  protected processBatchUpdate(response: Response): Promise<Batch> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = Batch.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<Batch>(null as any)
  }

  /**
   * @return No response body
   */
  batchDelete(batchId: number): Promise<void> {
    let url_ = this.baseUrl + '/analytics/batches/{batchId}/'
    if (batchId === undefined || batchId === null) {
      throw new Error("The parameter 'batchId' must be defined.")
    }
    url_ = url_.replace('{batchId}', encodeURIComponent('' + batchId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {},
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processBatchDelete(_response)
    })
  }

  protected processBatchDelete(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 204) {
      return response.text().then(_responseText => {
        return
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<void>(null as any)
  }

  siteAll(): Promise<Site[]> {
    let url_ = this.baseUrl + '/analytics/sites/'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSiteAll(_response)
    })
  }

  protected processSiteAll(response: Response): Promise<Site[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        if (Array.isArray(resultData200)) {
          result200 = [] as any
          for (let item of resultData200) {
            result200!.push(Site.fromJS(item))
          }
        } else {
          result200 = <any> null
        }
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<Site[]>(null as any)
  }

  siteCreate(body: Site): Promise<Site> {
    let url_ = this.baseUrl + '/analytics/sites/'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSiteCreate(_response)
    })
  }

  protected processSiteCreate(response: Response): Promise<Site> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = Site.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<Site>(null as any)
  }

  siteDetail(siteId: number): Promise<Site> {
    let url_ = this.baseUrl + '/analytics/sites/{siteId}/'
    if (siteId === undefined || siteId === null) {
      throw new Error("The parameter 'siteId' must be defined.")
    }
    url_ = url_.replace('{siteId}', encodeURIComponent('' + siteId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSiteDetail(_response)
    })
  }

  protected processSiteDetail(response: Response): Promise<Site> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = Site.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<Site>(null as any)
  }

  siteUpdate(siteId: number, body: PatchedSite | undefined): Promise<Site> {
    let url_ = this.baseUrl + '/analytics/sites/{siteId}/'
    if (siteId === undefined || siteId === null) {
      throw new Error("The parameter 'siteId' must be defined.")
    }
    url_ = url_.replace('{siteId}', encodeURIComponent('' + siteId))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSiteUpdate(_response)
    })
  }

  protected processSiteUpdate(response: Response): Promise<Site> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = Site.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<Site>(null as any)
  }

  siteDelete(siteId: number): Promise<{ [key: string]: any }> {
    let url_ = this.baseUrl + '/analytics/sites/{siteId}/'
    if (siteId === undefined || siteId === null) {
      throw new Error("The parameter 'siteId' must be defined.")
    }
    url_ = url_.replace('{siteId}', encodeURIComponent('' + siteId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSiteDelete(_response)
    })
  }

  protected processSiteDelete(response: Response): Promise<{ [key: string]: any }> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200) {
          result200 = {} as any
          for (let key in resultData200) {
            if (resultData200.hasOwnProperty(key)) {
              ;(<any> result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any> null
            }
          }
        } else {
          result200 = <any> null
        }
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<{ [key: string]: any }>(null as any)
  }

  siteSummary(siteId: number): Promise<SiteSummary> {
    let url_ = this.baseUrl + '/analytics/sites/{siteId}/summary'
    if (siteId === undefined || siteId === null) {
      throw new Error("The parameter 'siteId' must be defined.")
    }
    url_ = url_.replace('{siteId}', encodeURIComponent('' + siteId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSiteSummary(_response)
    })
  }

  protected processSiteSummary(response: Response): Promise<SiteSummary> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = SiteSummary.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<SiteSummary>(null as any)
  }

  siteSummaryAll(): Promise<SiteSummary[]> {
    let url_ = this.baseUrl + '/analytics/sites/summary'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSiteSummaryAll(_response)
    })
  }

  protected processSiteSummaryAll(response: Response): Promise<SiteSummary[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        if (Array.isArray(resultData200)) {
          result200 = [] as any
          for (let item of resultData200) {
            result200!.push(SiteSummary.fromJS(item))
          }
        } else {
          result200 = <any> null
        }
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<SiteSummary[]>(null as any)
  }

  apiSchemaRetrieve(format: Format | undefined, lang: Lang | undefined): Promise<{ [key: string]: any }> {
    let url_ = this.baseUrl + '/api/schema/?'
    if (format === null) {
      throw new Error("The parameter 'format' cannot be null.")
    } else if (format !== undefined) {
      url_ += 'format=' + encodeURIComponent('' + format) + '&'
    }
    if (lang === null) {
      throw new Error("The parameter 'lang' cannot be null.")
    } else if (lang !== undefined) {
      url_ += 'lang=' + encodeURIComponent('' + lang) + '&'
    }
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/vnd.oai.openapi',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processApiSchemaRetrieve(_response)
    })
  }

  protected processApiSchemaRetrieve(response: Response): Promise<{ [key: string]: any }> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200) {
          result200 = {} as any
          for (let key in resultData200) {
            if (resultData200.hasOwnProperty(key)) {
              ;(<any> result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any> null
            }
          }
        } else {
          result200 = <any> null
        }
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<{ [key: string]: any }>(null as any)
  }

  authenticationLogin(body: AuthUser): Promise<User> {
    let url_ = this.baseUrl + '/auth/login/'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAuthenticationLogin(_response)
    })
  }

  protected processAuthenticationLogin(response: Response): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = User.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<User>(null as any)
  }

  authenticationLogout(): Promise<{ [key: string]: any }> {
    let url_ = this.baseUrl + '/auth/logout/'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'POST',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAuthenticationLogout(_response)
    })
  }

  protected processAuthenticationLogout(response: Response): Promise<{ [key: string]: any }> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        if (resultData200) {
          result200 = {} as any
          for (let key in resultData200) {
            if (resultData200.hasOwnProperty(key)) {
              ;(<any> result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any> null
            }
          }
        } else {
          result200 = <any> null
        }
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<{ [key: string]: any }>(null as any)
  }

  authenticationRegister(body: User): Promise<AuthUser> {
    let url_ = this.baseUrl + '/auth/register/'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAuthenticationRegister(_response)
    })
  }

  protected processAuthenticationRegister(response: Response): Promise<AuthUser> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = AuthUser.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<AuthUser>(null as any)
  }

  siteMap(): Promise<SiteMap[]> {
    let url_ = this.baseUrl + '/map/sites/'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSiteMap(_response)
    })
  }

  protected processSiteMap(response: Response): Promise<SiteMap[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        if (Array.isArray(resultData200)) {
          result200 = [] as any
          for (let item of resultData200) {
            result200!.push(SiteMap.fromJS(item))
          }
        } else {
          result200 = <any> null
        }
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<SiteMap[]>(null as any)
  }

  postAll(): Promise<Post[]> {
    let url_ = this.baseUrl + '/social/posts/'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostAll(_response)
    })
  }

  protected processPostAll(response: Response): Promise<Post[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        if (Array.isArray(resultData200)) {
          result200 = [] as any
          for (let item of resultData200) {
            result200!.push(Post.fromJS(item))
          }
        } else {
          result200 = <any> null
        }
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<Post[]>(null as any)
  }

  postCreate(body: Post): Promise<Post> {
    let url_ = this.baseUrl + '/social/posts/'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostCreate(_response)
    })
  }

  protected processPostCreate(response: Response): Promise<Post> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = Post.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<Post>(null as any)
  }

  commentAll(postId: number): Promise<Comment[]> {
    let url_ = this.baseUrl + '/social/posts/{postId}/comments/'
    if (postId === undefined || postId === null) {
      throw new Error("The parameter 'postId' must be defined.")
    }
    url_ = url_.replace('{postId}', encodeURIComponent('' + postId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCommentAll(_response)
    })
  }

  protected processCommentAll(response: Response): Promise<Comment[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        if (Array.isArray(resultData200)) {
          result200 = [] as any
          for (let item of resultData200) {
            result200!.push(Comment.fromJS(item))
          }
        } else {
          result200 = <any> null
        }
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<Comment[]>(null as any)
  }

  commentCreate(postId: number, body: Comment | undefined): Promise<Comment> {
    let url_ = this.baseUrl + '/social/posts/{postId}/comments/'
    if (postId === undefined || postId === null) {
      throw new Error("The parameter 'postId' must be defined.")
    }
    url_ = url_.replace('{postId}', encodeURIComponent('' + postId))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCommentCreate(_response)
    })
  }

  protected processCommentCreate(response: Response): Promise<Comment> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = Comment.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<Comment>(null as any)
  }

  /**
   * @return No response body
   */
  commentDelete(commentId: number, postId: number): Promise<void> {
    let url_ = this.baseUrl + '/social/posts/{postId}/comments/{commentId}/'
    if (commentId === undefined || commentId === null) {
      throw new Error("The parameter 'commentId' must be defined.")
    }
    url_ = url_.replace('{commentId}', encodeURIComponent('' + commentId))
    if (postId === undefined || postId === null) {
      throw new Error("The parameter 'postId' must be defined.")
    }
    url_ = url_.replace('{postId}', encodeURIComponent('' + postId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {},
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCommentDelete(_response)
    })
  }

  protected processCommentDelete(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 204) {
      return response.text().then(_responseText => {
        return
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<void>(null as any)
  }

  likeAll(postId: number, body: Like | undefined): Promise<Like> {
    let url_ = this.baseUrl + '/social/posts/{postId}/likes/'
    if (postId === undefined || postId === null) {
      throw new Error("The parameter 'postId' must be defined.")
    }
    url_ = url_.replace('{postId}', encodeURIComponent('' + postId))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLikeAll(_response)
    })
  }

  protected processLikeAll(response: Response): Promise<Like> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = Like.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<Like>(null as any)
  }

  siteSocialAll(): Promise<SiteSocial> {
    let url_ = this.baseUrl + '/social/sites/'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSiteSocialAll(_response)
    })
  }

  protected processSiteSocialAll(response: Response): Promise<SiteSocial> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = SiteSocial.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<SiteSocial>(null as any)
  }

  siteSocial(siteId: number): Promise<SiteSocial> {
    let url_ = this.baseUrl + '/social/sites/{siteId}/'
    if (siteId === undefined || siteId === null) {
      throw new Error("The parameter 'siteId' must be defined.")
    }
    url_ = url_.replace('{siteId}', encodeURIComponent('' + siteId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSiteSocial(_response)
    })
  }

  protected processSiteSocial(response: Response): Promise<SiteSocial> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = SiteSocial.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<SiteSocial>(null as any)
  }

  announcementUpdate(siteId: number, body: PatchedAnnouncement | undefined): Promise<Announcement> {
    let url_ = this.baseUrl + '/social/sites/{siteId}/announcements/'
    if (siteId === undefined || siteId === null) {
      throw new Error("The parameter 'siteId' must be defined.")
    }
    url_ = url_.replace('{siteId}', encodeURIComponent('' + siteId))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAnnouncementUpdate(_response)
    })
  }

  protected processAnnouncementUpdate(response: Response): Promise<Announcement> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = Announcement.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<Announcement>(null as any)
  }

  contactUpdate(contactId: number, siteId: number, body: PatchedContact | undefined): Promise<Contact> {
    let url_ = this.baseUrl + '/social/sites/{siteId}/contacts/{contactId}/'
    if (contactId === undefined || contactId === null) {
      throw new Error("The parameter 'contactId' must be defined.")
    }
    url_ = url_.replace('{contactId}', encodeURIComponent('' + contactId))
    if (siteId === undefined || siteId === null) {
      throw new Error("The parameter 'siteId' must be defined.")
    }
    url_ = url_.replace('{siteId}', encodeURIComponent('' + siteId))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processContactUpdate(_response)
    })
  }

  protected processContactUpdate(response: Response): Promise<Contact> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = Contact.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<Contact>(null as any)
  }

  widgetCreate(siteId: number, body: Widget | undefined): Promise<Widget> {
    let url_ = this.baseUrl + '/social/sites/{siteId}/widgets/'
    if (siteId === undefined || siteId === null) {
      throw new Error("The parameter 'siteId' must be defined.")
    }
    url_ = url_.replace('{siteId}', encodeURIComponent('' + siteId))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processWidgetCreate(_response)
    })
  }

  protected processWidgetCreate(response: Response): Promise<Widget> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = Widget.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<Widget>(null as any)
  }

  widgetUpdate(siteId: number, widgetId: number, body: PatchedWidget | undefined): Promise<Widget> {
    let url_ = this.baseUrl + '/social/sites/{siteId}/widgets/{widgetId}/'
    if (siteId === undefined || siteId === null) {
      throw new Error("The parameter 'siteId' must be defined.")
    }
    url_ = url_.replace('{siteId}', encodeURIComponent('' + siteId))
    if (widgetId === undefined || widgetId === null) {
      throw new Error("The parameter 'widgetId' must be defined.")
    }
    url_ = url_.replace('{widgetId}', encodeURIComponent('' + widgetId))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processWidgetUpdate(_response)
    })
  }

  protected processWidgetUpdate(response: Response): Promise<Widget> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = Widget.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<Widget>(null as any)
  }

  /**
   * @return No response body
   */
  widgetDelete(siteId: number, widgetId: number): Promise<void> {
    let url_ = this.baseUrl + '/social/sites/{siteId}/widgets/{widgetId}/'
    if (siteId === undefined || siteId === null) {
      throw new Error("The parameter 'siteId' must be defined.")
    }
    url_ = url_.replace('{siteId}', encodeURIComponent('' + siteId))
    if (widgetId === undefined || widgetId === null) {
      throw new Error("The parameter 'widgetId' must be defined.")
    }
    url_ = url_.replace('{widgetId}', encodeURIComponent('' + widgetId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {},
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processWidgetDelete(_response)
    })
  }

  protected processWidgetDelete(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 204) {
      return response.text().then(_responseText => {
        return
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<void>(null as any)
  }

  userAll(): Promise<User[]> {
    let url_ = this.baseUrl + '/users/'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserAll(_response)
    })
  }

  protected processUserAll(response: Response): Promise<User[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        if (Array.isArray(resultData200)) {
          result200 = [] as any
          for (let item of resultData200) {
            result200!.push(User.fromJS(item))
          }
        } else {
          result200 = <any> null
        }
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<User[]>(null as any)
  }

  userCreate(body: User): Promise<User> {
    let url_ = this.baseUrl + '/users/'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserCreate(_response)
    })
  }

  protected processUserCreate(response: Response): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = User.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<User>(null as any)
  }

  userDetail(userId: number): Promise<User> {
    let url_ = this.baseUrl + '/users/{userId}/'
    if (userId === undefined || userId === null) {
      throw new Error("The parameter 'userId' must be defined.")
    }
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserDetail(_response)
    })
  }

  protected processUserDetail(response: Response): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = User.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<User>(null as any)
  }

  userUpdate(userId: number, body: PatchedUser | undefined): Promise<User> {
    let url_ = this.baseUrl + '/users/{userId}/'
    if (userId === undefined || userId === null) {
      throw new Error("The parameter 'userId' must be defined.")
    }
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserUpdate(_response)
    })
  }

  protected processUserUpdate(response: Response): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = User.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<User>(null as any)
  }

  userCurrentUser(): Promise<User> {
    let url_ = this.baseUrl + '/users/current_user/'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserCurrentUser(_response)
    })
  }

  protected processUserCurrentUser(response: Response): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) response.headers.forEach((v: any, k: any) => _headers[k] = v)
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = User.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers)
      })
    }
    return Promise.resolve<User>(null as any)
  }
}

export class Announcement implements IAnnouncement {
  readonly id!: number
  body?: string | undefined
  link?: string | undefined;

  [key: string]: any

  constructor(data?: IAnnouncement) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      this.body = _data['body']
      this.link = _data['link']
    }
  }

  static fromJS(data: any): Announcement {
    data = typeof data === 'object' ? data : {}
    let result = new Announcement()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['body'] = this.body
    data['link'] = this.link
    return data
  }
}

export interface IAnnouncement {
  id: number
  body?: string | undefined
  link?: string | undefined

  [key: string]: any
}

export class AuthUser implements IAuthUser {
  readonly id!: number
  /** Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. */
  username!: string
  email?: string
  password!: string;

  [key: string]: any

  constructor(data?: IAuthUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      this.username = _data['username']
      this.email = _data['email']
      this.password = _data['password']
    }
  }

  static fromJS(data: any): AuthUser {
    data = typeof data === 'object' ? data : {}
    let result = new AuthUser()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['username'] = this.username
    data['email'] = this.email
    data['password'] = this.password
    return data
  }
}

export interface IAuthUser {
  id: number
  /** Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. */
  username: string
  email?: string
  password: string

  [key: string]: any
}

export class Batch implements IBatch {
  readonly id!: number
  createdAt?: Date | undefined
  name?: string | undefined
  sponsor?: string | undefined
  size?: string | undefined
  soilCondition?: string | undefined
  totalNumberSeed?: number | undefined
  totalPropagation?: number | undefined
  site?: number | undefined;

  [key: string]: any

  constructor(data?: IBatch) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      this.createdAt = _data['createdAt'] ? new Date(_data['createdAt'].toString()) : <any> undefined
      this.name = _data['name']
      this.sponsor = _data['sponsor']
      this.size = _data['size']
      this.soilCondition = _data['soilCondition']
      this.totalNumberSeed = _data['totalNumberSeed']
      this.totalPropagation = _data['totalPropagation']
      this.site = _data['site']
    }
  }

  static fromJS(data: any): Batch {
    data = typeof data === 'object' ? data : {}
    let result = new Batch()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any> undefined
    data['name'] = this.name
    data['sponsor'] = this.sponsor
    data['size'] = this.size
    data['soilCondition'] = this.soilCondition
    data['totalNumberSeed'] = this.totalNumberSeed
    data['totalPropagation'] = this.totalPropagation
    data['site'] = this.site
    return data
  }
}

export interface IBatch {
  id: number
  createdAt?: Date | undefined
  name?: string | undefined
  sponsor?: string | undefined
  size?: string | undefined
  soilCondition?: string | undefined
  totalNumberSeed?: number | undefined
  totalPropagation?: number | undefined
  site?: number | undefined

  [key: string]: any
}

export class BatchAnalytics implements IBatchAnalytics {
  readonly id!: number
  name?: string | undefined
  size?: string | undefined
  soilCondition?: string | undefined
  readonly fertilizers!: string
  readonly mulchLayers!: string
  readonly supportedSpecies!: string
  readonly plantCount!: string
  readonly survivedCount!: string
  readonly replaceCount!: string
  readonly seedCollectedCount!: string
  readonly seeds!: string
  readonly species!: string;

  [key: string]: any

  constructor(data?: IBatchAnalytics) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      this.name = _data['name']
      this.size = _data['size']
      this.soilCondition = _data['soilCondition']
      ;(<any> this).fertilizers = _data['fertilizers']
      ;(<any> this).mulchLayers = _data['mulchLayers']
      ;(<any> this).supportedSpecies = _data['supportedSpecies']
      ;(<any> this).plantCount = _data['plantCount']
      ;(<any> this).survivedCount = _data['survivedCount']
      ;(<any> this).replaceCount = _data['replaceCount']
      ;(<any> this).seedCollectedCount = _data['seedCollectedCount']
      ;(<any> this).seeds = _data['seeds']
      ;(<any> this).species = _data['species']
    }
  }

  static fromJS(data: any): BatchAnalytics {
    data = typeof data === 'object' ? data : {}
    let result = new BatchAnalytics()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['name'] = this.name
    data['size'] = this.size
    data['soilCondition'] = this.soilCondition
    data['fertilizers'] = this.fertilizers
    data['mulchLayers'] = this.mulchLayers
    data['supportedSpecies'] = this.supportedSpecies
    data['plantCount'] = this.plantCount
    data['survivedCount'] = this.survivedCount
    data['replaceCount'] = this.replaceCount
    data['seedCollectedCount'] = this.seedCollectedCount
    data['seeds'] = this.seeds
    data['species'] = this.species
    return data
  }
}

export interface IBatchAnalytics {
  id: number
  name?: string | undefined
  size?: string | undefined
  soilCondition?: string | undefined
  fertilizers: string
  mulchLayers: string
  supportedSpecies: string
  plantCount: string
  survivedCount: string
  replaceCount: string
  seedCollectedCount: string
  seeds: string
  species: string

  [key: string]: any
}

export class Comment implements IComment {
  readonly id!: number
  body?: string | undefined
  authUser?: number | undefined
  createdAt?: Date | undefined;

  [key: string]: any

  constructor(data?: IComment) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      this.body = _data['body']
      this.authUser = _data['authUser']
      this.createdAt = _data['createdAt'] ? new Date(_data['createdAt'].toString()) : <any> undefined
    }
  }

  static fromJS(data: any): Comment {
    data = typeof data === 'object' ? data : {}
    let result = new Comment()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['body'] = this.body
    data['authUser'] = this.authUser
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any> undefined
    return data
  }
}

export interface IComment {
  id: number
  body?: string | undefined
  authUser?: number | undefined
  createdAt?: Date | undefined

  [key: string]: any
}

export class Contact implements IContact {
  readonly id!: number
  address?: string | undefined
  email?: string | undefined
  phone?: string | undefined
  facebookLink?: string | undefined
  xLink?: string | undefined
  instagramLink?: string | undefined
  linkedinLink?: string | undefined;

  [key: string]: any

  constructor(data?: IContact) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      this.address = _data['address']
      this.email = _data['email']
      this.phone = _data['phone']
      this.facebookLink = _data['facebookLink']
      this.xLink = _data['xLink']
      this.instagramLink = _data['instagramLink']
      this.linkedinLink = _data['linkedinLink']
    }
  }

  static fromJS(data: any): Contact {
    data = typeof data === 'object' ? data : {}
    let result = new Contact()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['address'] = this.address
    data['email'] = this.email
    data['phone'] = this.phone
    data['facebookLink'] = this.facebookLink
    data['xLink'] = this.xLink
    data['instagramLink'] = this.instagramLink
    data['linkedinLink'] = this.linkedinLink
    return data
  }
}

export interface IContact {
  id: number
  address?: string | undefined
  email?: string | undefined
  phone?: string | undefined
  facebookLink?: string | undefined
  xLink?: string | undefined
  instagramLink?: string | undefined
  linkedinLink?: string | undefined

  [key: string]: any
}

export class Coordinates implements ICoordinates {
  readonly id!: number
  dmsLatitude?: string | undefined
  dmsLongitude?: string | undefined
  ddLatitude?: string | undefined
  ddLongitude?: string | undefined
  address?: string | undefined;

  [key: string]: any

  constructor(data?: ICoordinates) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      this.dmsLatitude = _data['dmsLatitude']
      this.dmsLongitude = _data['dmsLongitude']
      this.ddLatitude = _data['ddLatitude']
      this.ddLongitude = _data['ddLongitude']
      this.address = _data['address']
    }
  }

  static fromJS(data: any): Coordinates {
    data = typeof data === 'object' ? data : {}
    let result = new Coordinates()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['dmsLatitude'] = this.dmsLatitude
    data['dmsLongitude'] = this.dmsLongitude
    data['ddLatitude'] = this.ddLatitude
    data['ddLongitude'] = this.ddLongitude
    data['address'] = this.address
    return data
  }
}

export interface ICoordinates {
  id: number
  dmsLatitude?: string | undefined
  dmsLongitude?: string | undefined
  ddLatitude?: string | undefined
  ddLongitude?: string | undefined
  address?: string | undefined

  [key: string]: any
}

export class Like implements ILike {
  readonly id!: number
  authUser?: number | undefined
  post?: number | undefined;

  [key: string]: any

  constructor(data?: ILike) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      this.authUser = _data['authUser']
      this.post = _data['post']
    }
  }

  static fromJS(data: any): Like {
    data = typeof data === 'object' ? data : {}
    let result = new Like()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['authUser'] = this.authUser
    data['post'] = this.post
    return data
  }
}

export interface ILike {
  id: number
  authUser?: number | undefined
  post?: number | undefined

  [key: string]: any
}

export class PatchedAnnouncement implements IPatchedAnnouncement {
  readonly id?: number
  body?: string | undefined
  link?: string | undefined;

  [key: string]: any

  constructor(data?: IPatchedAnnouncement) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      this.body = _data['body']
      this.link = _data['link']
    }
  }

  static fromJS(data: any): PatchedAnnouncement {
    data = typeof data === 'object' ? data : {}
    let result = new PatchedAnnouncement()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['body'] = this.body
    data['link'] = this.link
    return data
  }
}

export interface IPatchedAnnouncement {
  id?: number
  body?: string | undefined
  link?: string | undefined

  [key: string]: any
}

export class PatchedBatch implements IPatchedBatch {
  readonly id?: number
  createdAt?: Date | undefined
  name?: string | undefined
  sponsor?: string | undefined
  size?: string | undefined
  soilCondition?: string | undefined
  totalNumberSeed?: number | undefined
  totalPropagation?: number | undefined
  site?: number | undefined;

  [key: string]: any

  constructor(data?: IPatchedBatch) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      this.createdAt = _data['createdAt'] ? new Date(_data['createdAt'].toString()) : <any> undefined
      this.name = _data['name']
      this.sponsor = _data['sponsor']
      this.size = _data['size']
      this.soilCondition = _data['soilCondition']
      this.totalNumberSeed = _data['totalNumberSeed']
      this.totalPropagation = _data['totalPropagation']
      this.site = _data['site']
    }
  }

  static fromJS(data: any): PatchedBatch {
    data = typeof data === 'object' ? data : {}
    let result = new PatchedBatch()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any> undefined
    data['name'] = this.name
    data['sponsor'] = this.sponsor
    data['size'] = this.size
    data['soilCondition'] = this.soilCondition
    data['totalNumberSeed'] = this.totalNumberSeed
    data['totalPropagation'] = this.totalPropagation
    data['site'] = this.site
    return data
  }
}

export interface IPatchedBatch {
  id?: number
  createdAt?: Date | undefined
  name?: string | undefined
  sponsor?: string | undefined
  size?: string | undefined
  soilCondition?: string | undefined
  totalNumberSeed?: number | undefined
  totalPropagation?: number | undefined
  site?: number | undefined

  [key: string]: any
}

export class PatchedContact implements IPatchedContact {
  readonly id?: number
  address?: string | undefined
  email?: string | undefined
  phone?: string | undefined
  facebookLink?: string | undefined
  xLink?: string | undefined
  instagramLink?: string | undefined
  linkedinLink?: string | undefined;

  [key: string]: any

  constructor(data?: IPatchedContact) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      this.address = _data['address']
      this.email = _data['email']
      this.phone = _data['phone']
      this.facebookLink = _data['facebookLink']
      this.xLink = _data['xLink']
      this.instagramLink = _data['instagramLink']
      this.linkedinLink = _data['linkedinLink']
    }
  }

  static fromJS(data: any): PatchedContact {
    data = typeof data === 'object' ? data : {}
    let result = new PatchedContact()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['address'] = this.address
    data['email'] = this.email
    data['phone'] = this.phone
    data['facebookLink'] = this.facebookLink
    data['xLink'] = this.xLink
    data['instagramLink'] = this.instagramLink
    data['linkedinLink'] = this.linkedinLink
    return data
  }
}

export interface IPatchedContact {
  id?: number
  address?: string | undefined
  email?: string | undefined
  phone?: string | undefined
  facebookLink?: string | undefined
  xLink?: string | undefined
  instagramLink?: string | undefined
  linkedinLink?: string | undefined

  [key: string]: any
}

export class PatchedSite implements IPatchedSite {
  readonly id?: number
  siteType?: SiteType
  coordinate?: Coordinates
  readonly siteTreeSpecies?: string
  contact?: Contact
  announcement?: Announcement
  name?: string | undefined
  description?: string | undefined
  size?: string | undefined
  researchPartnership?: boolean | undefined
  visibleMap?: boolean | undefined
  visitorCount?: number | undefined
  image?: number | undefined;

  [key: string]: any

  constructor(data?: IPatchedSite) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      this.siteType = _data['siteType'] ? SiteType.fromJS(_data['siteType']) : <any> undefined
      this.coordinate = _data['coordinate'] ? Coordinates.fromJS(_data['coordinate']) : <any> undefined
      ;(<any> this).siteTreeSpecies = _data['siteTreeSpecies']
      this.contact = _data['contact'] ? Contact.fromJS(_data['contact']) : <any> undefined
      this.announcement = _data['announcement'] ? Announcement.fromJS(_data['announcement']) : <any> undefined
      this.name = _data['name']
      this.description = _data['description']
      this.size = _data['size']
      this.researchPartnership = _data['researchPartnership']
      this.visibleMap = _data['visibleMap']
      this.visitorCount = _data['visitorCount']
      this.image = _data['image']
    }
  }

  static fromJS(data: any): PatchedSite {
    data = typeof data === 'object' ? data : {}
    let result = new PatchedSite()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['siteType'] = this.siteType ? this.siteType.toJSON() : <any> undefined
    data['coordinate'] = this.coordinate ? this.coordinate.toJSON() : <any> undefined
    data['siteTreeSpecies'] = this.siteTreeSpecies
    data['contact'] = this.contact ? this.contact.toJSON() : <any> undefined
    data['announcement'] = this.announcement ? this.announcement.toJSON() : <any> undefined
    data['name'] = this.name
    data['description'] = this.description
    data['size'] = this.size
    data['researchPartnership'] = this.researchPartnership
    data['visibleMap'] = this.visibleMap
    data['visitorCount'] = this.visitorCount
    data['image'] = this.image
    return data
  }
}

export interface IPatchedSite {
  id?: number
  siteType?: SiteType
  coordinate?: Coordinates
  siteTreeSpecies?: string
  contact?: Contact
  announcement?: Announcement
  name?: string | undefined
  description?: string | undefined
  size?: string | undefined
  researchPartnership?: boolean | undefined
  visibleMap?: boolean | undefined
  visitorCount?: number | undefined
  image?: number | undefined

  [key: string]: any
}

export class PatchedUser implements IPatchedUser {
  readonly id?: number
  password?: string
  lastLogin?: Date | undefined
  /** Designates that this user has all permissions without explicitly assigning them. */
  isSuperuser?: boolean
  /** Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. */
  username?: string
  firstName?: string
  lastName?: string
  email?: string
  /** Designates whether the user can log into this admin site. */
  isStaff?: boolean
  /** Designates whether this user should be treated as active. Unselect this instead of deleting accounts. */
  isActive?: boolean
  dateJoined?: Date
  /** The groups this user belongs to. A user will get all permissions granted to each of their groups. */
  groups?: number[]
  /** Specific permissions for this user. */
  userPermissions?: number[];

  [key: string]: any

  constructor(data?: IPatchedUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      this.password = _data['password']
      this.lastLogin = _data['lastLogin'] ? new Date(_data['lastLogin'].toString()) : <any> undefined
      this.isSuperuser = _data['isSuperuser']
      this.username = _data['username']
      this.firstName = _data['firstName']
      this.lastName = _data['lastName']
      this.email = _data['email']
      this.isStaff = _data['isStaff']
      this.isActive = _data['isActive']
      this.dateJoined = _data['dateJoined'] ? new Date(_data['dateJoined'].toString()) : <any> undefined
      if (Array.isArray(_data['groups'])) {
        this.groups = [] as any
        for (let item of _data['groups']) {
          this.groups!.push(item)
        }
      }
      if (Array.isArray(_data['userPermissions'])) {
        this.userPermissions = [] as any
        for (let item of _data['userPermissions']) {
          this.userPermissions!.push(item)
        }
      }
    }
  }

  static fromJS(data: any): PatchedUser {
    data = typeof data === 'object' ? data : {}
    let result = new PatchedUser()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['password'] = this.password
    data['lastLogin'] = this.lastLogin ? this.lastLogin.toISOString() : <any> undefined
    data['isSuperuser'] = this.isSuperuser
    data['username'] = this.username
    data['firstName'] = this.firstName
    data['lastName'] = this.lastName
    data['email'] = this.email
    data['isStaff'] = this.isStaff
    data['isActive'] = this.isActive
    data['dateJoined'] = this.dateJoined ? this.dateJoined.toISOString() : <any> undefined
    if (Array.isArray(this.groups)) {
      data['groups'] = []
      for (let item of this.groups) {
        data['groups'].push(item)
      }
    }
    if (Array.isArray(this.userPermissions)) {
      data['userPermissions'] = []
      for (let item of this.userPermissions) {
        data['userPermissions'].push(item)
      }
    }
    return data
  }
}

export interface IPatchedUser {
  id?: number
  password?: string
  lastLogin?: Date | undefined
  /** Designates that this user has all permissions without explicitly assigning them. */
  isSuperuser?: boolean
  /** Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. */
  username?: string
  firstName?: string
  lastName?: string
  email?: string
  /** Designates whether the user can log into this admin site. */
  isStaff?: boolean
  /** Designates whether this user should be treated as active. Unselect this instead of deleting accounts. */
  isActive?: boolean
  dateJoined?: Date
  /** The groups this user belongs to. A user will get all permissions granted to each of their groups. */
  groups?: number[]
  /** Specific permissions for this user. */
  userPermissions?: number[]

  [key: string]: any
}

export class PatchedWidget implements IPatchedWidget {
  readonly id?: number
  title?: string | undefined
  body?: string | undefined
  site?: number | undefined;

  [key: string]: any

  constructor(data?: IPatchedWidget) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      this.title = _data['title']
      this.body = _data['body']
      this.site = _data['site']
    }
  }

  static fromJS(data: any): PatchedWidget {
    data = typeof data === 'object' ? data : {}
    let result = new PatchedWidget()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['title'] = this.title
    data['body'] = this.body
    data['site'] = this.site
    return data
  }
}

export interface IPatchedWidget {
  id?: number
  title?: string | undefined
  body?: string | undefined
  site?: number | undefined

  [key: string]: any
}

export class Post implements IPost {
  readonly id!: number
  site!: SiteOverview
  createdAt?: Date | undefined
  body?: string | undefined
  likeCount?: number | undefined
  shareCount?: number | undefined
  readonly commentCount!: string
  readonly hasLiked!: string;

  [key: string]: any

  constructor(data?: IPost) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
    if (!data) {
      this.site = new SiteOverview()
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      this.site = _data['site'] ? SiteOverview.fromJS(_data['site']) : new SiteOverview()
      this.createdAt = _data['createdAt'] ? new Date(_data['createdAt'].toString()) : <any> undefined
      this.body = _data['body']
      this.likeCount = _data['likeCount']
      this.shareCount = _data['shareCount']
      ;(<any> this).commentCount = _data['commentCount']
      ;(<any> this).hasLiked = _data['hasLiked']
    }
  }

  static fromJS(data: any): Post {
    data = typeof data === 'object' ? data : {}
    let result = new Post()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['site'] = this.site ? this.site.toJSON() : <any> undefined
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any> undefined
    data['body'] = this.body
    data['likeCount'] = this.likeCount
    data['shareCount'] = this.shareCount
    data['commentCount'] = this.commentCount
    data['hasLiked'] = this.hasLiked
    return data
  }
}

export interface IPost {
  id: number
  site: SiteOverview
  createdAt?: Date | undefined
  body?: string | undefined
  likeCount?: number | undefined
  shareCount?: number | undefined
  commentCount: string
  hasLiked: string

  [key: string]: any
}

export class Site implements ISite {
  readonly id!: number
  siteType!: SiteType
  coordinate!: Coordinates
  readonly siteTreeSpecies!: string
  contact!: Contact
  announcement!: Announcement
  name?: string | undefined
  description?: string | undefined
  size?: string | undefined
  researchPartnership?: boolean | undefined
  visibleMap?: boolean | undefined
  visitorCount?: number | undefined
  image?: number | undefined;

  [key: string]: any

  constructor(data?: ISite) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
    if (!data) {
      this.siteType = new SiteType()
      this.coordinate = new Coordinates()
      this.contact = new Contact()
      this.announcement = new Announcement()
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      this.siteType = _data['siteType'] ? SiteType.fromJS(_data['siteType']) : new SiteType()
      this.coordinate = _data['coordinate'] ? Coordinates.fromJS(_data['coordinate']) : new Coordinates()
      ;(<any> this).siteTreeSpecies = _data['siteTreeSpecies']
      this.contact = _data['contact'] ? Contact.fromJS(_data['contact']) : new Contact()
      this.announcement = _data['announcement'] ? Announcement.fromJS(_data['announcement']) : new Announcement()
      this.name = _data['name']
      this.description = _data['description']
      this.size = _data['size']
      this.researchPartnership = _data['researchPartnership']
      this.visibleMap = _data['visibleMap']
      this.visitorCount = _data['visitorCount']
      this.image = _data['image']
    }
  }

  static fromJS(data: any): Site {
    data = typeof data === 'object' ? data : {}
    let result = new Site()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['siteType'] = this.siteType ? this.siteType.toJSON() : <any> undefined
    data['coordinate'] = this.coordinate ? this.coordinate.toJSON() : <any> undefined
    data['siteTreeSpecies'] = this.siteTreeSpecies
    data['contact'] = this.contact ? this.contact.toJSON() : <any> undefined
    data['announcement'] = this.announcement ? this.announcement.toJSON() : <any> undefined
    data['name'] = this.name
    data['description'] = this.description
    data['size'] = this.size
    data['researchPartnership'] = this.researchPartnership
    data['visibleMap'] = this.visibleMap
    data['visitorCount'] = this.visitorCount
    data['image'] = this.image
    return data
  }
}

export interface ISite {
  id: number
  siteType: SiteType
  coordinate: Coordinates
  siteTreeSpecies: string
  contact: Contact
  announcement: Announcement
  name?: string | undefined
  description?: string | undefined
  size?: string | undefined
  researchPartnership?: boolean | undefined
  visibleMap?: boolean | undefined
  visitorCount?: number | undefined
  image?: number | undefined

  [key: string]: any
}

export class SiteMap implements ISiteMap {
  readonly id!: number
  name?: string | undefined
  siteType!: SiteType
  readonly coordinates!: string
  image?: number | undefined;

  [key: string]: any

  constructor(data?: ISiteMap) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
    if (!data) {
      this.siteType = new SiteType()
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      this.name = _data['name']
      this.siteType = _data['siteType'] ? SiteType.fromJS(_data['siteType']) : new SiteType()
      ;(<any> this).coordinates = _data['coordinates']
      this.image = _data['image']
    }
  }

  static fromJS(data: any): SiteMap {
    data = typeof data === 'object' ? data : {}
    let result = new SiteMap()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['name'] = this.name
    data['siteType'] = this.siteType ? this.siteType.toJSON() : <any> undefined
    data['coordinates'] = this.coordinates
    data['image'] = this.image
    return data
  }
}

export interface ISiteMap {
  id: number
  name?: string | undefined
  siteType: SiteType
  coordinates: string
  image?: number | undefined

  [key: string]: any
}

export class SiteOverview implements ISiteOverview {
  readonly id!: number
  name?: string | undefined;

  [key: string]: any

  constructor(data?: ISiteOverview) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      this.name = _data['name']
    }
  }

  static fromJS(data: any): SiteOverview {
    data = typeof data === 'object' ? data : {}
    let result = new SiteOverview()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['name'] = this.name
    return data
  }
}

export interface ISiteOverview {
  id: number
  name?: string | undefined

  [key: string]: any
}

export class SiteSocial implements ISiteSocial {
  name?: string | undefined
  siteType!: SiteType
  image?: number | undefined
  description?: string | undefined
  contact!: Contact
  announcement!: Announcement
  readonly sponsors!: string[]
  readonly widget!: Widget[];

  [key: string]: any

  constructor(data?: ISiteSocial) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
    if (!data) {
      this.siteType = new SiteType()
      this.contact = new Contact()
      this.announcement = new Announcement()
      this.sponsors = []
      this.widget = []
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      this.name = _data['name']
      this.siteType = _data['siteType'] ? SiteType.fromJS(_data['siteType']) : new SiteType()
      this.image = _data['image']
      this.description = _data['description']
      this.contact = _data['contact'] ? Contact.fromJS(_data['contact']) : new Contact()
      this.announcement = _data['announcement'] ? Announcement.fromJS(_data['announcement']) : new Announcement()
      if (Array.isArray(_data['sponsors'])) {
        ;(<any> this).sponsors = [] as any
        for (let item of _data['sponsors']) {
          ;(<any> this).sponsors!.push(item)
        }
      }
      if (Array.isArray(_data['widget'])) {
        ;(<any> this).widget = [] as any
        for (let item of _data['widget']) {
          ;(<any> this).widget!.push(Widget.fromJS(item))
        }
      }
    }
  }

  static fromJS(data: any): SiteSocial {
    data = typeof data === 'object' ? data : {}
    let result = new SiteSocial()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['name'] = this.name
    data['siteType'] = this.siteType ? this.siteType.toJSON() : <any> undefined
    data['image'] = this.image
    data['description'] = this.description
    data['contact'] = this.contact ? this.contact.toJSON() : <any> undefined
    data['announcement'] = this.announcement ? this.announcement.toJSON() : <any> undefined
    if (Array.isArray(this.sponsors)) {
      data['sponsors'] = []
      for (let item of this.sponsors) {
        data['sponsors'].push(item)
      }
    }
    if (Array.isArray(this.widget)) {
      data['widget'] = []
      for (let item of this.widget) {
        data['widget'].push(item.toJSON())
      }
    }
    return data
  }
}

export interface ISiteSocial {
  name?: string | undefined
  siteType: SiteType
  image?: number | undefined
  description?: string | undefined
  contact: Contact
  announcement: Announcement
  sponsors: string[]
  widget: Widget[]

  [key: string]: any
}

export class SiteSummary implements ISiteSummary {
  name?: string | undefined
  siteType!: SiteType
  readonly plantCount!: string
  readonly survivedCount!: string
  readonly propagationCount!: string
  visitorCount?: number | undefined
  readonly sponsor!: string
  readonly progress!: string;

  [key: string]: any

  constructor(data?: ISiteSummary) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
    if (!data) {
      this.siteType = new SiteType()
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      this.name = _data['name']
      this.siteType = _data['siteType'] ? SiteType.fromJS(_data['siteType']) : new SiteType()
      ;(<any> this).plantCount = _data['plantCount']
      ;(<any> this).survivedCount = _data['survivedCount']
      ;(<any> this).propagationCount = _data['propagationCount']
      this.visitorCount = _data['visitorCount']
      ;(<any> this).sponsor = _data['sponsor']
      ;(<any> this).progress = _data['progress']
    }
  }

  static fromJS(data: any): SiteSummary {
    data = typeof data === 'object' ? data : {}
    let result = new SiteSummary()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['name'] = this.name
    data['siteType'] = this.siteType ? this.siteType.toJSON() : <any> undefined
    data['plantCount'] = this.plantCount
    data['survivedCount'] = this.survivedCount
    data['propagationCount'] = this.propagationCount
    data['visitorCount'] = this.visitorCount
    data['sponsor'] = this.sponsor
    data['progress'] = this.progress
    return data
  }
}

export interface ISiteSummary {
  name?: string | undefined
  siteType: SiteType
  plantCount: string
  survivedCount: string
  propagationCount: string
  visitorCount?: number | undefined
  sponsor: string
  progress: string

  [key: string]: any
}

export class SiteType implements ISiteType {
  readonly id!: number
  readonly en!: string
  readonly fr!: string;

  [key: string]: any

  constructor(data?: ISiteType) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      ;(<any> this).en = _data['en']
      ;(<any> this).fr = _data['fr']
    }
  }

  static fromJS(data: any): SiteType {
    data = typeof data === 'object' ? data : {}
    let result = new SiteType()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['en'] = this.en
    data['fr'] = this.fr
    return data
  }
}

export interface ISiteType {
  id: number
  en: string
  fr: string

  [key: string]: any
}

export class User implements IUser {
  readonly id!: number
  password!: string
  lastLogin?: Date | undefined
  /** Designates that this user has all permissions without explicitly assigning them. */
  isSuperuser?: boolean
  /** Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. */
  username!: string
  firstName?: string
  lastName?: string
  email?: string
  /** Designates whether the user can log into this admin site. */
  isStaff?: boolean
  /** Designates whether this user should be treated as active. Unselect this instead of deleting accounts. */
  isActive?: boolean
  dateJoined?: Date
  /** The groups this user belongs to. A user will get all permissions granted to each of their groups. */
  groups?: number[]
  /** Specific permissions for this user. */
  userPermissions?: number[];

  [key: string]: any

  constructor(data?: IUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      this.password = _data['password']
      this.lastLogin = _data['lastLogin'] ? new Date(_data['lastLogin'].toString()) : <any> undefined
      this.isSuperuser = _data['isSuperuser']
      this.username = _data['username']
      this.firstName = _data['firstName']
      this.lastName = _data['lastName']
      this.email = _data['email']
      this.isStaff = _data['isStaff']
      this.isActive = _data['isActive']
      this.dateJoined = _data['dateJoined'] ? new Date(_data['dateJoined'].toString()) : <any> undefined
      if (Array.isArray(_data['groups'])) {
        this.groups = [] as any
        for (let item of _data['groups']) {
          this.groups!.push(item)
        }
      }
      if (Array.isArray(_data['userPermissions'])) {
        this.userPermissions = [] as any
        for (let item of _data['userPermissions']) {
          this.userPermissions!.push(item)
        }
      }
    }
  }

  static fromJS(data: any): User {
    data = typeof data === 'object' ? data : {}
    let result = new User()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['password'] = this.password
    data['lastLogin'] = this.lastLogin ? this.lastLogin.toISOString() : <any> undefined
    data['isSuperuser'] = this.isSuperuser
    data['username'] = this.username
    data['firstName'] = this.firstName
    data['lastName'] = this.lastName
    data['email'] = this.email
    data['isStaff'] = this.isStaff
    data['isActive'] = this.isActive
    data['dateJoined'] = this.dateJoined ? this.dateJoined.toISOString() : <any> undefined
    if (Array.isArray(this.groups)) {
      data['groups'] = []
      for (let item of this.groups) {
        data['groups'].push(item)
      }
    }
    if (Array.isArray(this.userPermissions)) {
      data['userPermissions'] = []
      for (let item of this.userPermissions) {
        data['userPermissions'].push(item)
      }
    }
    return data
  }
}

export interface IUser {
  id: number
  password: string
  lastLogin?: Date | undefined
  /** Designates that this user has all permissions without explicitly assigning them. */
  isSuperuser?: boolean
  /** Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. */
  username: string
  firstName?: string
  lastName?: string
  email?: string
  /** Designates whether the user can log into this admin site. */
  isStaff?: boolean
  /** Designates whether this user should be treated as active. Unselect this instead of deleting accounts. */
  isActive?: boolean
  dateJoined?: Date
  /** The groups this user belongs to. A user will get all permissions granted to each of their groups. */
  groups?: number[]
  /** Specific permissions for this user. */
  userPermissions?: number[]

  [key: string]: any
}

export class Widget implements IWidget {
  readonly id!: number
  title?: string | undefined
  body?: string | undefined
  site?: number | undefined;

  [key: string]: any

  constructor(data?: IWidget) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          ;(<any> this)[property] = (<any> data)[property]
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) {
          this[property] = _data[property]
        }
      }
      ;(<any> this).id = _data['id']
      this.title = _data['title']
      this.body = _data['body']
      this.site = _data['site']
    }
  }

  static fromJS(data: any): Widget {
    data = typeof data === 'object' ? data : {}
    let result = new Widget()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        data[property] = this[property]
      }
    }
    data['id'] = this.id
    data['title'] = this.title
    data['body'] = this.body
    data['site'] = this.site
    return data
  }
}

export interface IWidget {
  id: number
  title?: string | undefined
  body?: string | undefined
  site?: number | undefined

  [key: string]: any
}

export enum Format {
  Json = 'json',
  Yaml = 'yaml',
}

export enum Lang {
  Af = 'af',
  Ar = 'ar',
  ArDz = 'ar-dz',
  Ast = 'ast',
  Az = 'az',
  Be = 'be',
  Bg = 'bg',
  Bn = 'bn',
  Br = 'br',
  Bs = 'bs',
  Ca = 'ca',
  Ckb = 'ckb',
  Cs = 'cs',
  Cy = 'cy',
  Da = 'da',
  De = 'de',
  Dsb = 'dsb',
  El = 'el',
  En = 'en',
  EnAu = 'en-au',
  EnGb = 'en-gb',
  Eo = 'eo',
  Es = 'es',
  EsAr = 'es-ar',
  EsCo = 'es-co',
  EsMx = 'es-mx',
  EsNi = 'es-ni',
  EsVe = 'es-ve',
  Et = 'et',
  Eu = 'eu',
  Fa = 'fa',
  Fi = 'fi',
  Fr = 'fr',
  Fy = 'fy',
  Ga = 'ga',
  Gd = 'gd',
  Gl = 'gl',
  He = 'he',
  Hi = 'hi',
  Hr = 'hr',
  Hsb = 'hsb',
  Hu = 'hu',
  Hy = 'hy',
  Ia = 'ia',
  Id = 'id',
  Ig = 'ig',
  Io = 'io',
  Is = 'is',
  It = 'it',
  Ja = 'ja',
  Ka = 'ka',
  Kab = 'kab',
  Kk = 'kk',
  Km = 'km',
  Kn = 'kn',
  Ko = 'ko',
  Ky = 'ky',
  Lb = 'lb',
  Lt = 'lt',
  Lv = 'lv',
  Mk = 'mk',
  Ml = 'ml',
  Mn = 'mn',
  Mr = 'mr',
  Ms = 'ms',
  My = 'my',
  Nb = 'nb',
  Ne = 'ne',
  Nl = 'nl',
  Nn = 'nn',
  Os = 'os',
  Pa = 'pa',
  Pl = 'pl',
  Pt = 'pt',
  PtBr = 'pt-br',
  Ro = 'ro',
  Ru = 'ru',
  Sk = 'sk',
  Sl = 'sl',
  Sq = 'sq',
  Sr = 'sr',
  SrLatn = 'sr-latn',
  Sv = 'sv',
  Sw = 'sw',
  Ta = 'ta',
  Te = 'te',
  Tg = 'tg',
  Th = 'th',
  Tk = 'tk',
  Tr = 'tr',
  Tt = 'tt',
  Udm = 'udm',
  Ug = 'ug',
  Uk = 'uk',
  Ur = 'ur',
  Uz = 'uz',
  Vi = 'vi',
  ZhHans = 'zh-hans',
  ZhHant = 'zh-hant',
}

export class ApiException extends Error {
  override message: string
  status: number
  response: string
  headers: { [key: string]: any }
  result: any

  constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
    super()

    this.message = message
    this.status = status
    this.response = response
    this.headers = headers
    this.result = result
  }

  protected isApiException = true

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): any {
  if (result !== null && result !== undefined) {
    throw result
  } else {
    throw new ApiException(message, status, response, headers, null)
  }
}
